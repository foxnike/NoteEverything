# 变量

## 数据类型
solidty是一种**静态类型语言**：使用变量前需要声明其数据类型；
### 值类型 
* bool类型  
    length：  
    >关于bool类型赋值的奇怪bug：  
    使用Web端Remix进行远程合约调试，预期返回bool类型的方法返回空
* 整数类型  
    根据类型的长度分为（数字代表数据类型长度）  
    uint8~uint256  
    int8~int256   
    **int与uint默认使用256长度**  
    >**使用uint256与int256的好处**：256位大小的数据在memory存储中读取成本更低；
* 浮点类型
    >目前Solidity对浮点数的支持可能有编译器版本限制
* 枚举类型  
    枚举类型同C语言一致，枚举类型返回的结果为uint256，允许显式转换，不允许隐式转换（编译时检查）
    <img style="display: block; margin: 0 auto;" src="../Images/EnumError.png"/>

* 地址类型  
    大小为20个字节，160bits；
    >例：0x5B38Da6a701c568545dCfcB03FcB875f56beddC4

    **地址类型变量有一系列属性与函数**  
    balance：返回钱包地址余额  
    transfer：**x.transfer(10)** 调用者（合约）向x进行安全转账，不成功的转账会返回异常；  
    send：作用同transfer，但会返回转账是否成功，转账失败不会导致合约异常终止；  
    call：在不声明合约实例的基础上调用相关的方法，（**call偏底层，不推荐使用，常规的做法应该是调用合约对象的方法**）  
    
### 引用数据类型
* 数组类型
* string类型
    >使用UTF-8编码的任意长度字符串，无尾随零
* struct类型
* mapping类型

## 变量声明位置  
变量声明的位置决定了变量的作用域，变量的存储方式（与智能合约的运行有关）；根据声明位置可分为：
* 状态变量  
  状态变量一般声明于：合约内，方法外，作用域为合约内部，其存储方式**必须**为storage，类似于存储于硬盘，会上链（感兴趣可以了解以太坊智能合约的运行方式）  
  >状态变量可以使用可见性关键字进行修饰：  
  **public**：编译器会自动生成getter函数，可以在合约外部访问  
  **internal**：在合约以及派生合约种可以访问  
  **private**；只能在该合约中访问
* 局部变量  
  局部变量声明于：方法内部，存储方式为memory，类似于存储在内存中，数据不会上链；（引用数据类型需要声明时指定存储方式为memory）
  >局部变量可以声明为storage类型，但只能引用到已经声明的storage变量（因为你无法在方法内初始化一个storage变量）
* 全局变量  
  全局变量声明在合约之外，可以提供区块链和交易的属性，如block提供当前区块的相关属性，msg提供当前消息的相关属性，now可以返回当前的时间戳;  


在合约中的变量有不同的存储位置,变量数据位置的设置与合约的Gas消耗有关:  
solidty提供三种变量存储方式：
* storage  
    用于存储永久数据，类似于存储于硬盘上，其在函数调用与交易之间是持久的；合约的状态变量默认存储位置为storage，但存储在storage的Gas开销较大（开销指在部署和调用合约时，对storage变量的初始化、读取、修改）
* memory  
    一般用于存储临时变量（变量声明时会说明），在每次消息调用时生成的合约实例，有线性的内存，其读写有一定的Gas开销；  
    >256位及其整数倍大小的变量的读取Gas消耗更小；（更小的变量需要先扩展到256位才能读取，扩展需要消耗Gas）
* stack
    EVM是基于栈的虚拟机，所有的计算都在栈结构上执行，目前已知的值类型的局部变量存储在栈上，其开销是最小的
* calldata  
    严格意义上，calldata不算是一种数据类型存储方式；具体的使用方式还在探索中（挖坑）

## 常量  
只能用于修饰国定值的值类型数据与字符串数据，需要在编译时确定值；